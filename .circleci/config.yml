version: 2.1

orbs:
  node: circleci/node@5.0.2

# ============================================================
# COMMANDS
# ============================================================
commands:

  # ----------------------------------------------------------
  # Install Salesforce CLI + Java
  # ----------------------------------------------------------
  install-tooling:
    steps:
      - restore_cache:
          keys:
            - sf-cli-cache-v1

      - run:
          name: Install Salesforce CLI and Java
          command: |
            if ! sf --version > /dev/null 2>&1; then
              sudo npm install -g @salesforce/cli
            fi
            sudo apt-get update && sudo apt-get install -y openjdk-17-jdk

            echo 'export PATH=$(npm bin -g):$PATH' >> "$BASH_ENV"
            source "$BASH_ENV"

            sf --version

      - save_cache:
          key: sf-cli-cache-v1
          paths:
            - ~/.npm
            - /usr/local/lib/node_modules
            - /usr/local/bin

  # ----------------------------------------------------------
  # JWT Authentication
  # ----------------------------------------------------------
  jwt-auth:
    parameters:
      target_env:
        type: string
    steps:
      - run:
          name: Decode JWT key
          command: |
            echo "${JWT_KEY_<< parameters.target_env >>}" | base64 -d > server.key 2>/dev/null || \
            echo "${JWT_KEY_<< parameters.target_env >>}" > server.key
            chmod 600 server.key

      - run:
          name: Authenticate (<< parameters.target_env >>)
          command: |
            sf org login jwt \
              --username "${SF_USERNAME_<< parameters.target_env >>}" \
              --jwt-key-file server.key \
              --client-id "${SF_CONSUMER_KEY_<< parameters.target_env >>}" \
              --instance-url "${SF_INSTANCEURL_<< parameters.target_env >>}" \
              --alias target \
              --set-default

  # ----------------------------------------------------------
  # DEPLOY WITH TAGS (Delta + Dependent Tests + JUnit export)
  # ----------------------------------------------------------
  deploy-with-tags:
    parameters:
      test_level:
        type: string
        default: RunLocalTests
      tag_prefix:
        type: string
    steps:

      # ------------------------------------------------------
      # Find Most Recent Tag
      # ------------------------------------------------------
      - run:
          name: Find Most Recent Tag
          command: |
            PROJECT_DIR=$(dirname "$(find . -name sfdx-project.json | head -n 1)")
            cd "$PROJECT_DIR"

            git fetch --tags
            currentRef=0
            currentTag=""

            tags=$(git tag -l '<< parameters.tag_prefix >>-[0-9]*' | sort -V)

            for tag in $tags; do
              ref=$(echo "$tag" | cut -d '-' -f 2)
              if [ "$ref" -gt "$currentRef" ]; then
                currentRef="$ref"
                currentTag="$tag"
              fi
            done

            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
            echo "export TAG_PREFIX=<< parameters.tag_prefix >>" >> $BASH_ENV

      # ------------------------------------------------------
      # Build package.xml
      # ------------------------------------------------------
      - run:
          name: Build Package Manifest
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(dirname "$(find . -name sfdx-project.json | head -n 1)")
            cd "$PROJECT_DIR"

            if [ "$CURRENT_REF" -eq 0 ]; then
              find force-app/main/default -type f \( \
                -name "*.cls" -o -name "*.trigger" -o -name "*.page" \
                -o -name "*.component" -o -name "*.cmp" -o -name "*.app" \
                -o -name "*-meta.xml" -o -name "*.js-meta.xml" \
              \) > files.txt
            else
              git diff --name-only "$CURRENT_TAG" HEAD | grep '^force-app/' > changed.txt || true
              > files.txt
              while read -r f; do
                case "$f" in
                  *.cls|*.trigger|*.page|*.component|*.cmp|*.app|*-meta.xml|*.js-meta.xml)
                      echo "$f" >> files.txt ;;
                esac
              done < changed.txt
            fi

            if [ -s files.txt ]; then
              mapfile -t arr < files.txt
              sf project generate manifest -p "${arr[@]}"
              echo "export CHANGES_FOUND=true" >> $BASH_ENV
            else
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
            fi

      # ------------------------------------------------------
      # Identify dependent test classes
      # ------------------------------------------------------
      - run:
          name: Identify Dependent Test Classes
          command: |
            set -e
            source $BASH_ENV

            PROJECT_DIR=$(dirname "$(find . -name sfdx-project.json | head -n 1)")
            cd "$PROJECT_DIR"

            grep -oP '(?<=classes/)[A-Za-z0-9_]+(?=\.cls)' files.txt > changed_classes.txt || true

            if [ ! -s changed_classes.txt ]; then
              echo "export TEST_CLASSES=\"\"" >> $BASH_ENV
              exit 0
            fi

            list=$(paste -sd "," changed_classes.txt | sed "s/,/','/g")
            list="'${list}'"

            sf data query \
              --query "SELECT Id FROM ApexClass WHERE Name IN ($list)" \
              --use-tooling-api --json > ids.json

            IDS=$(jq -r '.result.records[].Id' ids.json | xargs)
            [ -z "$IDS" ] && echo "export TEST_CLASSES=\"\"" >> $BASH_ENV && exit 0

            idsFormatted="'$(echo "$IDS" | sed "s/ /','/g")'"

            sf data query \
              --query "SELECT MetadataComponentName FROM MetadataComponentDependency WHERE RefMetadataComponentId IN ($idsFormatted)" \
              --use-tooling-api --json > deps.json

            TEST_CLASSES=$(jq -r '.result.records[].MetadataComponentName' deps.json | xargs)
            echo "export TEST_CLASSES=\"$TEST_CLASSES\"" >> $BASH_ENV

      # ------------------------------------------------------
      # DEPLOY + RUN TESTS ONCE + CAPTURE DEPLOY ID
      # ------------------------------------------------------
      - run:
          name: Deploy Metadata (Run Tests Once)
          command: |
            set -e
            source $BASH_ENV

            mkdir -p test-results

            PROJECT_DIR=$(dirname "$(find . -name sfdx-project.json | head -n 1)")
            cd "$PROJECT_DIR"

            if [ "$CHANGES_FOUND" != "true" ]; then
              echo "export DEPLOYMENT_SUCCESS=false" >> $BASH_ENV
              exit 0
            fi

            if [ -n "$TEST_CLASSES" ]; then
              TEST_ARGS=""
              for t in $TEST_CLASSES; do
                TEST_ARGS="$TEST_ARGS --tests $t"
              done

              OUT=$(sf project deploy start \
                --manifest package.xml \
                --test-level RunSpecifiedTests \
                $TEST_ARGS \
                --ignore-conflicts \
                --wait 360 \
                --json)
            else
              OUT=$(sf project deploy start \
                --manifest package.xml \
                --test-level NoTestRun \
                --ignore-conflicts \
                --wait 360 \
                --json)
            fi

            echo "$OUT" > deploy-start.json
            DEPLOY_ID=$(jq -r '.result.id' deploy-start.json)
            echo "$DEPLOY_ID" > deploy-id.txt
            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV

      # ------------------------------------------------------
      # Extract JUnit XML from deploy report
      # ------------------------------------------------------
      - run:
          name: Extract JUnit XML
          command: |
            set -e
            DEPLOY_ID=$(cat deploy-id.txt)

            sf project deploy report \
              --job-id "$DEPLOY_ID" \
              --json > deploy-report.json

            node << 'EOF'
const fs = require('fs')
const data = JSON.parse(fs.readFileSync('deploy-report.json', 'utf8'))
const tests = data.result.runTestResult?.records || []
let xml = '<?xml version="1.0"?>\n<testsuites>\n'
tests.forEach(t => {
  xml += `  <testsuite name="${t.name}" tests="1">\n`
  xml += `    <testcase classname="${t.name}" name="${t.name}">\n`
  if (t.message) xml += `      <failure message="${t.message}">${t.stackTrace}</failure>\n`
  xml += '    </testcase>\n'
  xml += '  </testsuite>\n'
})
xml += '</testsuites>'
fs.writeFileSync('test-results/salesforce-tests.xml', xml)
EOF

      - store_test_results:
          path: test-results

      - store_artifacts:
          path: test-results
          destination: apex-tests


      # ------------------------------------------------------
      # Create New Tag
      # ------------------------------------------------------
      - run:
          name: Create & Push Tag
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(dirname "$(find . -name sfdx-project.json | head -n 1)")
            cd "$PROJECT_DIR"

            if [ "$DEPLOYMENT_SUCCESS" = "true" ]; then
              NEXT=$((CURRENT_REF + 1))
              NEWTAG="$TAG_PREFIX-$NEXT"
              git config user.email "circleci@example.com"
              git config user.name "CircleCI"
              git tag "$NEWTAG"
              git push origin "$NEWTAG"
            fi

# ============================================================
# JOBS
# ============================================================
jobs:
  deploy-intqa:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: INTQA
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>

  deploy-staging:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: STAGINGUAT
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>

  deploy-main:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: PROD
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>

# ============================================================
# WORKFLOWS
# ============================================================
workflows:
  version: 2
  build-test-deploy:
    jobs:
      - deploy-intqa:
          context: sf-intqa
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: BRInt

      - deploy-staging:
          context: sf-staging
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: BRStaging

      - deploy-main:
          context: sf-prod
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: main
