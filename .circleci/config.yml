version: 2.1

orbs:
  node: circleci/node@5.0.2

# ============================================================
# COMMANDS
# ============================================================
commands:

  # ----------------------------------------------------------
  # Install Salesforce CLI + Java
  # ----------------------------------------------------------
  install-tooling:
    steps:
      - restore_cache:
          keys:
            - sf-cli-cache-v1

      - run:
          name: Install Salesforce CLI and Java
          command: |
            echo "ðŸ”§ Installing tooling..."

            if ! sf --version > /dev/null 2>&1; then
              echo "ðŸ“¦ Installing Salesforce CLI..."
              sudo npm install -g @salesforce/cli
            fi

            echo "â˜• Installing Java..."
            sudo apt-get update && sudo apt-get install -y openjdk-17-jdk

            echo "ðŸ§­ Updating PATH..."
            echo 'export PATH=$(npm bin -g):$PATH' >> "$BASH_ENV"
            source "$BASH_ENV"

            sf --version
            echo "âœ… Finished installing tooling."

      - save_cache:
          key: sf-cli-cache-v1
          paths:
            - ~/.npm
            - /usr/local/lib/node_modules
            - /usr/local/bin


  # ----------------------------------------------------------
  # JWT Authentication (INTQA)
  # ----------------------------------------------------------
  jwt-auth-intqa:
    steps:
      - run:
          name: Decode JWT Key
          command: |
            echo "ðŸ” Decoding INTQA JWT key..."
            echo "$JWT_KEY_INTQA" | base64 -d > server.key 2>/dev/null || echo "$JWT_KEY_INTQA" > server.key
            chmod 600 server.key

      - run:
          name: Authenticate to INTQA
          command: |
            echo "ðŸ”‘ Authenticating INTQA..."
            sf org login jwt \
              --username "$SF_USERNAME_INTQA" \
              --jwt-key-file server.key \
              --client-id "$SF_CONSUMER_KEY_INTQA" \
              --instance-url "$SF_INSTANCEURL_INTQA" \
              --alias target \
              --set-default

            echo "âœ… Authenticated to INTQA."


  # ----------------------------------------------------------
  # JWT Authentication (STAGING)
  # ----------------------------------------------------------
  jwt-auth-staging:
    steps:
      - run:
          name: Decode JWT Key
          command: |
            echo "ðŸ” Decoding STAGING JWT key..."
            echo "$JWT_KEY_STAGINGUAT" | base64 -d > server.key 2>/dev/null || echo "$JWT_KEY_STAGINGUAT" > server.key
            chmod 600 server.key

      - run:
          name: Authenticate to STAGING
          command: |
            echo "ðŸ”‘ Authenticating STAGING..."
            sf org login jwt \
              --username "$SF_USERNAME_STAGINGUAT" \
              --jwt-key-file server.key \
              --client-id "$SF_CONSUMER_KEY_STAGINGUAT" \
              --instance-url "$SF_INSTANCEURL_STAGINGUAT" \
              --alias target \
              --set-default

            echo "âœ… Authenticated to STAGING."


  # ----------------------------------------------------------
  # JWT Authentication (PROD)
  # ----------------------------------------------------------
  jwt-auth-prod:
    steps:
      - run:
          name: Decode JWT Key
          command: |
            echo "ðŸ” Decoding PROD JWT key..."
            echo "$JWT_KEY_PROD" | base64 -d > server.key 2>/dev/null || echo "$JWT_KEY_PROD" > server.key
            chmod 600 server.key

      - run:
          name: Authenticate to PROD
          command: |
            echo "ðŸ”‘ Authenticating PROD..."
            sf org login jwt \
              --username "$SF_USERNAME_PROD" \
              --jwt-key-file server.key \
              --client-id "$SF_CONSUMER_KEY_PROD" \
              --instance-url "$SF_INSTANCEURL_PROD" \
              --alias target \
              --set-default

            echo "âœ… Authenticated to PROD."

# ----------------------------------------------------------
# DEPLOY LOGIC: INTQA (BRInt TAGS)
# ----------------------------------------------------------
  deploy-intqa-with-tags:
    steps:
      - run:
          name: Fetch latest tags
          command: |
            echo "ðŸ“¥ Fetching tags..."
            git fetch --tags
            echo "ðŸ· All tags:"
            git tag -l

      - run:
          name: Determine latest INTQA tag
          command: |
            PREFIX="BRInt"
            echo "ðŸ”Ž Using prefix: $PREFIX"

            currentRef=0
            currentTag=""

            tags=$(git tag -l "${PREFIX}-*")
            echo "ðŸ· Matching tags: $tags"

            if [ -n "$tags" ]; then
              for tag in $tags; do
                num=$(echo "$tag" | awk -F'-' '{print $NF}')
                if [ "$num" -gt "$currentRef" ]; then
                  currentRef="$num"
                  currentTag="$tag"
                fi
              done
            fi

            echo "ðŸ“Œ Latest tag: $currentTag"
            echo "ðŸ“Œ Latest ref: $currentRef"

            echo "export PREFIX=$PREFIX" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV

      - run:
          name: Build delta package
          command: |
            source $BASH_ENV
            echo "ðŸ“¦ Building delta package..."
            echo "ðŸ“¦ CURRENT_TAG: $CURRENT_TAG"
            echo "ðŸ“¦ CURRENT_REF: $CURRENT_REF"

            if [ "$CURRENT_REF" -eq 0 ]; then
              echo "âš ï¸ No previous tags â€” FULL deploy mode."

              if [ ! -d "force-app" ]; then
                echo "âš ï¸ No force-app folder found. Nothing to deploy."
                touch files.txt
              else
                echo "ðŸ“‚ Collecting full force-app..."
                find force-app -type f > files.txt || true
              fi
            else
              echo "ðŸ” Delta mode from $CURRENT_TAG â†’ HEAD"
              git diff --name-only "$CURRENT_TAG" HEAD | grep "^force-app/" > files.txt || true
            fi

            if [ ! -s files.txt ]; then
              echo "âŒ No changes found. Skipping deploy."
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
              exit 0
            fi

            echo "ðŸ“„ Changed files:"
            cat files.txt

            mapfile -t manifest_paths < files.txt

            sf project generate manifest -p "${manifest_paths[@]}"
            echo "export CHANGES_FOUND=true" >> $BASH_ENV
            echo "âœ… Manifest generated."

      - run:
          name: Deploy to INTQA
          command: |
            source $BASH_ENV

            echo "ðŸš€ Starting INTQA deploy..."
            echo "CHANGES_FOUND = $CHANGES_FOUND"

            if [ "$CHANGES_FOUND" != "true" ]; then
              echo "â­ï¸ Skipping deploy â€” no changes."
              exit 0
            fi

            DEPLOY_OUT=$(sf project deploy start --manifest package.xml --target-org target --wait 0 --verbose)

            echo "$DEPLOY_OUT"

            JOB_ID=$(echo "$DEPLOY_OUT" | grep -o "0Af[a-zA-Z0-9]\+")
            echo "ðŸ†” Job ID: $JOB_ID"

            if [ -z "$JOB_ID" ]; then
              echo "âŒ No JOB_ID found â€” failing."
              exit 1
            fi

            while true; do
              STATUS=$(sf project deploy report --job-id "$JOB_ID" --json | jq -r ".result.status")
              echo "ðŸ“Œ Status: $STATUS"
              if [[ "$STATUS" == "Succeeded" || "$STATUS" == "Failed" ]]; then break; fi
              sleep 15
            done

            if [ "$STATUS" == "Failed" ]; then
              echo "âŒ Deploy failed."
              exit 1
            fi

            echo "ðŸŽ‰ INTQA Deploy succeeded!"
            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV

      - run:
          name: Create new INTQA tag
          command: |
            source $BASH_ENV
            echo "ðŸ· Creating tag if success..."

            if [ "$DEPLOYMENT_SUCCESS" != "true" ]; then
              echo "âš ï¸ Not successful â€” no tag created."
              exit 0
            fi

            NEW_REF=$((CURRENT_REF + 1))
            NEW_TAG="${PREFIX}-${NEW_REF}"

            echo "ðŸ· Tagging: $NEW_TAG"
            git tag "$NEW_TAG"
            git push origin "$NEW_TAG"
            echo "ðŸŽ‰ Tag created: $NEW_TAG"

# ----------------------------------------------------------
# DEPLOY LOGIC: STAGING (BRStaging TAGS)
# ----------------------------------------------------------
  deploy-staging-with-tags:
    steps:
      - run:
          name: Fetch latest tags
          command: |
            echo "ðŸ“¥ Fetching tags..."
            git fetch --tags

      - run:
          name: Determine latest STAGING tag
          command: |
            PREFIX="BRStaging"
            echo "ðŸ”Ž Using prefix: $PREFIX"

            currentRef=0
            currentTag=""
            tags=$(git tag -l "${PREFIX}-*")

            if [ -n "$tags" ]; then
              for tag in $tags; do
                num=$(echo "$tag" | awk -F'-' '{print $NF}')
                if [ "$num" -gt "$currentRef" ]; then
                  currentRef="$num"
                  currentTag="$tag"
                fi
              done
            fi

            echo "ðŸ“Œ Latest tag: $currentTag"
            echo "ðŸ“Œ Latest ref: $currentRef"

            echo "export PREFIX=$PREFIX" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV

      - run:
          name: Build delta package
          command: |
            source $BASH_ENV

            if [ "$CURRENT_REF" -eq 0 ]; then
              if [ ! -d "force-app" ]; then
                touch files.txt
              else
                find force-app -type f > files.txt || true
              fi
            else
              git diff --name-only "$CURRENT_TAG" HEAD | grep "^force-app/" > files.txt || true
            fi

            if [ ! -s files.txt ]; then
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
              exit 0
            fi

            mapfile -t manifest_paths < files.txt
            sf project generate manifest -p "${manifest_paths[@]}"
            echo "export CHANGES_FOUND=true" >> $BASH_ENV

      - run:
          name: Deploy to STAGING
          command: |
            source $BASH_ENV

            if [ "$CHANGES_FOUND" != "true" ]; then exit 0; fi

            DEPLOY_OUT=$(sf project deploy start --manifest package.xml --target-org target --wait 0 --verbose)
            JOB_ID=$(echo "$DEPLOY_OUT" | grep -o "0Af[a-zA-Z0-9]\+")

            while true; do
              STATUS=$(sf project deploy report --job-id "$JOB_ID" --json | jq -r ".result.status")
              if [[ "$STATUS" == "Succeeded" || "$STATUS" == "Failed" ]]; then break; fi
              sleep 15
            done

            if [ "$STATUS" == "Failed" ]; then exit 1; fi

            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV

      - run:
          name: Create new STAGING tag
          command: |
            source $BASH_ENV

            if [ "$DEPLOYMENT_SUCCESS" != "true" ]; then exit 0; fi

            NEW_REF=$((CURRENT_REF + 1))
            NEW_TAG="${PREFIX}-${NEW_REF}"

            git tag "$NEW_TAG"
            git push origin "$NEW_TAG"

# ----------------------------------------------------------
# DEPLOY LOGIC: PROD (main TAGS)
# ----------------------------------------------------------
  deploy-prod-with-tags:
    steps:
      - run:
          name: Fetch latest tags
          command: |
            git fetch --tags

      - run:
          name: Determine latest PROD tag
          command: |
            PREFIX="main"

            currentRef=0
            currentTag=""
            tags=$(git tag -l "${PREFIX}-*")

            if [ -n "$tags" ]; then
              for tag in $tags; do
                num=$(echo "$tag" | awk -F'-' '{print $NF}')
                if [ "$num" -gt "$currentRef" ]; then
                  currentRef="$num"
                  currentTag="$tag"
                fi
              done
            fi

            echo "export PREFIX=$PREFIX" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV

      - run:
          name: Build delta package
          command: |
            source $BASH_ENV

            if [ "$CURRENT_REF" -eq 0 ]; then
              if [ ! -d "force-app" ]; then
                touch files.txt
              else
                find force-app -type f > files.txt || true
              fi
            else
              git diff --name-only "$CURRENT_TAG" HEAD | grep "^force-app/" > files.txt || true
            fi

            if [ ! -s files.txt ]; then
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
              exit 0
            fi

            mapfile -t manifest_paths < files.txt
            sf project generate manifest -p "${manifest_paths[@]}"
            echo "export CHANGES_FOUND=true" >> $BASH_ENV

      - run:
          name: Deploy to PROD
          command: |
            source $BASH_ENV

            if [ "$CHANGES_FOUND" != "true" ]; then exit 0; fi

            DEPLOY_OUT=$(sf project deploy start --manifest package.xml --target-org target --wait 0 --verbose)
            JOB_ID=$(echo "$DEPLOY_OUT" | grep -o "0Af[a-zA-Z0-9]\+")

            while true; do
              STATUS=$(sf project deploy report --job-id "$JOB_ID" --json | jq -r ".result.status")
              if [[ "$STATUS" == "Succeeded" || "$STATUS" == "Failed" ]]; then break; fi
              sleep 15
            done

            if [ "$STATUS" == "Failed" ]; then exit 1; fi

            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV

      - run:
          name: Create new PROD tag
          command: |
            source $BASH_ENV

            if [ "$DEPLOYMENT_SUCCESS" != "true" ]; then exit 0; fi

            NEW_REF=$((CURRENT_REF + 1))
            NEW_TAG="${PREFIX}-${NEW_REF}"

            git tag "$NEW_TAG"
            git push origin "$NEW_TAG"


# =====================================================================
# JOBS  
# =====================================================================
jobs:

  deploy-prod:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-prod
      - deploy-prod-with-tags

  deploy-staging:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-staging
      - deploy-staging-with-tags

  deploy-intqa:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-intqa
      - deploy-intqa-with-tags

  brint-test-pipeline:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-intqa
      - deploy-intqa-with-tags

  brstaging-test-pipeline:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-staging
      - deploy-staging-with-tags

  main-test-pipeline:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-prod
      - deploy-prod-with-tags


# =====================================================================
# WORKFLOWS
# =====================================================================
workflows:
  version: 2

  deploy-intqa-pipeline:
    jobs:
      - deploy-intqa:
          context: sf-intqa
          filters:
            branches:
              only: BRInt

  deploy-staging-pipeline:
    jobs:
      - deploy-staging:
          context: sf-staging
          filters:
            branches:
              only: BRStaging

  deploy-prod-pipeline:
    jobs:
      - deploy-prod:
          context: sf-prod
          filters:
            branches:
              only: main

  test-brint-deploy:
    jobs:
      - brint-test-pipeline:
          context: sf-intqa
          filters:
            branches:
              only: circleCI-BRInt

  test-brstaging-deploy:
    jobs:
      - brstaging-test-pipeline:
          context: sf-staging
          filters:
            branches:
              only: circleCI-BRStaging

  test-main-deploy:
    jobs:
      - main-test-pipeline:
          context: sf-prod
          filters:
              branches:
                only: circleCI-mainTest
