version: 2.1

orbs:
  node: circleci/node@5.0.2

# ============================================================
# COMMANDS
# ============================================================
commands:

  # ----------------------------------------------------------
  # Install Salesforce CLI + Java
  # ----------------------------------------------------------
  install-tooling:
    steps:
      - restore_cache:
          keys:
            - sf-cli-cache-v1

      - run:
          name: Install Salesforce CLI and Java
          command: |
            if ! sf --version > /dev/null 2>&1; then
              sudo npm install -g @salesforce/cli
            fi

            sudo apt-get update && sudo apt-get install -y openjdk-17-jdk
            
            echo 'export PATH=$(npm bin -g):$PATH' >> "$BASH_ENV"
            source "$BASH_ENV"

            sf --version

      - save_cache:
          key: sf-cli-cache-v1
          paths:
            - ~/.npm
            - /usr/local/lib/node_modules
            - /usr/local/bin

  # ----------------------------------------------------------
  # JWT Authentication
  # ----------------------------------------------------------
  jwt-auth:
    parameters:
      target_env:
        type: string
    steps:
      - run:
          name: Decode JWT key for << parameters.target_env >>
          command: |
            echo "${JWT_KEY_<< parameters.target_env >>}" | base64 -d > server.key 2>/dev/null || echo "${JWT_KEY_<< parameters.target_env >>}" > server.key
            chmod 600 server.key

      - run:
          name: Authenticate to Salesforce (<< parameters.target_env >>)
          command: |
            sf org login jwt \
              --username "${SF_USERNAME_<< parameters.target_env >>}" \
              --jwt-key-file server.key \
              --client-id "${SF_CONSUMER_KEY_<< parameters.target_env >>}" \
              --instance-url "${SF_INSTANCEURL_<< parameters.target_env >>}" \
              --alias target \
              --set-default

  # ----------------------------------------------------------
  # Tag-Based Deployment With Delta + Manifest + Dep Test Logic
  # ----------------------------------------------------------
  deploy-with-tags:
    parameters:
      tag_prefix:
        type: string
    steps:

      # ------------------------------------------------------
      # Identify most recent tag
      # ------------------------------------------------------
      - run:
          name: Find Most Recent Tag
          command: |
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            git fetch --tags

            currentRef=0
            currentTag=""

            tags=$(git tag -l '<< parameters.tag_prefix >>-[0-9]*' | sort -V)

            if [ -n "$tags" ]; then
              for tag in $tags; do
                refNum=$(echo $tag | cut -d '-' -f 2)
                if [ "$refNum" -gt "$currentRef" ]; then
                  currentRef=$refNum
                  currentTag=$tag
                fi
              done
              echo "Latest tag: $currentTag"
            else
              echo "No tags found for prefix << parameters.tag_prefix >>"
            fi

            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
            echo "export TAG_PREFIX=<< parameters.tag_prefix >>" >> $BASH_ENV


      # ------------------------------------------------------
      # Build package.xml (metadata-root aware)
      # ------------------------------------------------------
      - run:
          name: Build Package Manifest
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            echo "üîç Building deployable metadata file list..."

            # --------------------------------------------------
            # First deployment ‚Üí full metadata scan
            # --------------------------------------------------
            if [ "$CURRENT_REF" -eq 0 ]; then
              echo "üöÄ First deployment ‚Äî scanning entire force-app for metadata roots"

              find force-app/main/default -type f \
                \( -name "*.cls" \
                -o -name "*.trigger" \
                -o -name "*.page" \
                -o -name "*.component" \
                -o -name "*.cmp" \
                -o -name "*.app" \
                -o -name "*-meta.xml" \
                -o -name "*.js-meta.xml" \
                \) > files.txt || true

            else
              # --------------------------------------------------
              # Delta deployment ‚Üí restrict to changed metadata
              # --------------------------------------------------
              echo "üîÅ Delta deployment from tag: $CURRENT_TAG"

              git diff --name-only --relative $CURRENT_TAG HEAD | grep '^force-app/' > temp_files.txt || true

              > files.txt

              while IFS= read -r file; do
                # Keep only metadata-root files
                case "$file" in
                  *.cls|*.trigger|*.page|*.component|*.cmp|*.app|*-meta.xml|*.js-meta.xml)
                      if [ -f "$file" ]; then
                        echo "$file" >> files.txt
                      fi
                      ;;
                esac
              done < temp_files.txt
            fi

            echo "üëâ Final metadata root list:"
            cat files.txt || echo "(none)"

            # --------------------------------------------------
            # Generate manifest
            # --------------------------------------------------
            if [ -s files.txt ]; then
              mapfile -t manifest_paths < files.txt
              sf project generate manifest -p "${manifest_paths[@]}"
              echo "export CHANGES_FOUND=true" >> $BASH_ENV

              echo "üì¶ Generated package.xml:"
              cat package.xml
            else
              echo "‚ö†Ô∏è No deployable metadata roots found."
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
            fi



      # ------------------------------------------------------
      # Identify dependent test classes (ID-based + full debug)
      # ------------------------------------------------------
      - run:
          name: Identify Dependent Test Classes
          command: |
            set -euo pipefail
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            echo "üîç Extracting changed Apex class names from metadata roots..."
            grep -oP '(?<=classes/)[A-Za-z0-9_]+(?=\.cls$)' files.txt | sort -u > changed_classes.txt || true

            if [ ! -s changed_classes.txt ]; then
              echo "‚ö†Ô∏è No Apex classes changed."
              echo "export TEST_CLASSES=\"\"" >> $BASH_ENV
              exit 0
            fi

            echo "üìå Changed Apex classes:"
            cat changed_classes.txt

            # If any of the changed classes are test classes themselves (ending with Test or Tests),
            # run those tests directly ‚Äî no dependency lookup necessary.
            grep -E 'Test(s)?$' changed_classes.txt > changed_test_classes.txt || true
            if [ -s changed_test_classes.txt ]; then
              echo "üîé Changed classes include test classes ‚Äî will run these tests directly:"
              cat changed_test_classes.txt
              TEST_CLASSES=$(cat changed_test_classes.txt | xargs)
              echo "export TEST_CLASSES=\"$TEST_CLASSES\"" >> $BASH_ENV
              exit 0
            fi

            # Build name list for SOQL (non-test changed classes)
            classList=$(paste -sd "," changed_classes.txt | sed "s/,/','/g")
            classList="'${classList}'"
            echo "üìù SOQL class name list: ${classList}"

            # ---------------------------------------------------
            # Step 1 ‚Äî Get ApexClass IDs for changed classes
            # ---------------------------------------------------
            soqlClasses="SELECT Id, Name FROM ApexClass WHERE Name IN (${classList})"

            echo "üîé Running SOQL to fetch ApexClass IDs:"
            echo "$soqlClasses"

            sf data query \
              --query "$soqlClasses" \
              --use-tooling-api \
              --target-org target \
              --json > classIds.json

            echo "üì• Raw response (ApexClass IDs):"
            cat classIds.json

            # Parse IDs for dependency query
            if command -v jq >/dev/null 2>&1; then
              CLASS_IDS=$(jq -r '.result.records[].Id' classIds.json | xargs)
            else
              echo "‚ö†Ô∏è jq not found. Cannot parse ApexClass IDs."
              CLASS_IDS=""
            fi

            if [ -z "$CLASS_IDS" ]; then
              echo "‚ö†Ô∏è No ApexClass IDs found. Skipping dependent test discovery."
              echo "export TEST_CLASSES=\"\"" >> $BASH_ENV
              exit 0
            fi

            echo "üîó ApexClass IDs to inspect:"
            echo "$CLASS_IDS"

            # Convert space-separated ‚Üí SOQL IN ('id','id')
            classIdList=$(echo "$CLASS_IDS" | sed "s/ /','/g")
            classIdList="'${classIdList}'"

            # ---------------------------------------------------
            # Step 2 ‚Äî Query MetadataComponentDependency
            # ---------------------------------------------------
            soqlDep="SELECT MetadataComponentName
                     FROM MetadataComponentDependency
                     WHERE RefMetadataComponentType = 'ApexClass'
                     AND RefMetadataComponentId IN (${classIdList})
                     AND MetadataComponentType = 'ApexClass'"

            echo "üîé Running SOQL to fetch dependent test classes:"
            echo "$soqlDep"

            sf data query \
              --query "$soqlDep" \
              --use-tooling-api \
              --target-org target \
              --json > dependentTests.json || {
                echo '‚ö†Ô∏è Dependency SOQL failed ‚Äî falling back to no tests.'
                echo "export TEST_CLASSES=\"\"" >> $BASH_ENV
                exit 0
              }

            echo "üì• Raw dependency response:"
            cat dependentTests.json

            # Extract names
            if command -v jq >/dev/null 2>&1; then
              TEST_CLASSES=$(jq -r '.result.records[].MetadataComponentName' dependentTests.json | xargs)
            else
              echo "‚ö†Ô∏è jq missing ‚Äî cannot parse dependency results"
              TEST_CLASSES=""
            fi

            if [ -z "$TEST_CLASSES" ]; then
              echo "‚ö†Ô∏è No dependent test classes found."
              echo "export TEST_CLASSES=\"\"" >> $BASH_ENV
            else
              echo "üéØ Dependent Test Classes:"
              echo "$TEST_CLASSES"
              echo "export TEST_CLASSES=\"$TEST_CLASSES\"" >> $BASH_ENV
            fi



      # ------------------------------------------------------
      # Deploy with dynamic / conditional test execution 
      # ------------------------------------------------------
      - run:
          name: Deploy Metadata (Dynamic Tests)
          command: |
            set -euo pipefail

            DEPLOY_LOG=deploy.log

            # --- CANCELLATION TRAP ---
            # Define the function to be called on a TERM signal
            cancel_deployment() {
              # Try to extract Deploy ID from the streaming log first (quiet)
              JOB_ID=""
              if [ -f "$DEPLOY_LOG" ]; then
                JOB_ID=$(grep -m1 -oE 'Deploy ID: [A-Za-z0-9_]+' "$DEPLOY_LOG" | awk '{print $3}' || true)
              fi

              # Fallback: query sf for in-progress deploy if log didn't contain an ID
              if [ -z "$JOB_ID" ]; then
                JOB_ID=$(sf project deploy list --target-org target --status InProgress --limit 1 --json 2>/dev/null | jq -r '.result[0].id' 2>/dev/null) || true
                [ "$JOB_ID" = "null" ] && JOB_ID=""
              fi

              if [ -n "$JOB_ID" ]; then
                # Cancel the deployment quietly; suppress CLI output so we don't change the view
                sf project deploy cancel --job-id "$JOB_ID" --no-prompt --target-org target >/dev/null 2>&1 || true
              fi

              # Exit with code 130 to indicate cancellation to CI
              exit 130
            }

            # Set the trap. This catches the signal CircleCI sends when 'Cancel' is pressed.
            trap cancel_deployment TERM
            # --- END CANCELLATION TRAP ---

            # Helper to run deploy commands while streaming output to console + log
            run_deploy() {
              # $1 ... test-level (e.g. RunSpecifiedTests / RunLocalTests / NoTestRun)
              # $2 ... additional args (e.g. --tests MyTest)
              TEST_LEVEL_ARG="$1"
              ADDITIONAL_ARGS="$2"

              # Use bash -lc so tokenized args are expanded, pipe through tee to preserve output and capture Deploy ID
              ( set -o pipefail; bash -lc "sf project deploy start --manifest package.xml --target-org target --test-level $TEST_LEVEL_ARG $ADDITIONAL_ARGS --wait 360 --ignore-conflicts" ) 2>&1 | tee "$DEPLOY_LOG" &
              DEPLOY_PID=$!
              # Wait for the backgrounded deploy process; allow non-zero exit so cancel flows as expected
              wait $DEPLOY_PID || true
              return 0
            }

            # --- Your original script continues below ---
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            if [ "$CHANGES_FOUND" != "true" ]; then
              echo "‚ö†Ô∏è No delta changes detected ‚Äî performing full scan and deploying all components with full tests."

              # Build full manifest across the metadata root
              find force-app/main/default -type f \
                \( -name "*.cls" \
                -o -name "*.trigger" \
                -o -name "*.page" \
                -o -name "*.component" \
                -o -name "*.cmp" \
                -o -name "*.app" \
                -o -name "*-meta.xml" \
                -o -name "*.js-meta.xml" \
                \) > files.txt || true

              if [ -s files.txt ]; then
                mapfile -t manifest_paths < files.txt
                sf project generate manifest -p "${manifest_paths[@]}"
                # Persist for later steps and for subsequent commands in this shell
                echo "export CHANGES_FOUND=true" >> $BASH_ENV
                echo "export TEST_LEVEL=RunLocalTests" >> $BASH_ENV
                # Also export into the current shell so the rest of this run uses it immediately
                export CHANGES_FOUND=true
                export TEST_LEVEL=RunLocalTests
                echo "üì¶ Generated full package.xml for full deploy:" 
                cat package.xml || true
              else
                echo "‚ö†Ô∏è No metadata files found during full scan. Nothing to deploy."
                echo "export DEPLOYMENT_SUCCESS=false" >> $BASH_ENV
                exit 0
              fi
            fi

            mkdir -p test-results

            # --------------------------------------------------
            # CASE 1 ‚Äî Dependent tests found ‚Üí RunSpecifiedTests
            # --------------------------------------------------
            if [ -n "${TEST_CLASSES}" ]; then
              echo "üéØ Dependent test classes detected:"
              echo "$TEST_CLASSES"
              echo "üöÄ Deploying with RunSpecifiedTests..."

              TEST_ARGS=""
              for t in $TEST_CLASSES; do
                TEST_ARGS="$TEST_ARGS --tests $t"
              done

              echo "üî• Final TEST_ARGS: $TEST_ARGS"

              # Start deploy in background + tee; trap will cancel remote job using deploy.log
              run_deploy "RunSpecifiedTests" "$TEST_ARGS"

              echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV
              exit 0
            fi

            # --------------------------------------------------
            # CASE 2 ‚Äî NO dependent tests ‚Üí either run all local tests or NoTestRun
            # --------------------------------------------------
            echo "üõë No dependent Apex test classes found."
            if [ "${TEST_LEVEL:-}" = "RunLocalTests" ]; then
              echo "üì¶ Running all local tests (RunLocalTests) because full deploy requested."

              run_deploy "RunLocalTests" ""

              echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV
              exit 0
            fi

            echo "üì¶ Proceeding with NoTestRun."

            # Start NoTestRun deploy; output still visible and cancel handled via trap
            run_deploy "NoTestRun" ""

            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV


      # ------------------------------------------------------
      # Tag creation
      # ------------------------------------------------------
      - run:
          name: Create & Push Tag
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            if [ "$DEPLOYMENT_SUCCESS" = "true" ]; then
              NEW_REF=$((CURRENT_REF + 1))
              NEW_TAG="$TAG_PREFIX-$NEW_REF"

              git config user.email "circleci@example.com"
              git config user.name "CircleCI"
              git tag "$NEW_TAG"
              git push origin "$NEW_TAG"
            fi



# ============================================================
# JOBS PER ORG
# ============================================================
jobs:

  deploy-intqa:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: INTQA
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>

  deploy-staging:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: STAGINGUAT
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>

  deploy-main:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: PROD
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>



# ============================================================
# WORKFLOWS (BRANCH ‚Üí ENVIRONMENT)
# ============================================================
workflows:
  version: 2

  build-test-deploy:
    jobs:

      - deploy-intqa:
          context: sf-intqa
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: BRInt
            tags:
              ignore: /.*/

      - deploy-staging:
          context: sf-staging
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: BRStaging
            tags:
              ignore: /.*/

      - deploy-main:
          context: sf-prod
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: main
            tags:
              ignore: /.*/