version: 2.1

orbs:
  node: circleci/node@5.0.2
  slack: circleci/slack@4.12.5

# ============================================================
# PIPELINE PARAMETER (single dropdown)
# ============================================================
parameters:
  action_type:
    type: enum
    enum:
      - validate
      - deploy
    default: validate

# ============================================================
# COMMANDS
# ============================================================
commands:
  # ----------------------------------------------------------
  # Install Tooling: Node + SF CLI
  # ----------------------------------------------------------
  install-tooling:
    steps:
      - node/install:
          node-version: "20"
      - run:
          name: Install SF CLI
          command: |
            npm install -g @salesforce/cli
            sf --version

  # ----------------------------------------------------------
  # Find Test Classes from Gist Coverage Map
  # ----------------------------------------------------------
  
  find-test-classes:
    parameters:
      target_env:
        type: string
    steps:
      - run:
          name: Download Coverage Map from Gist
          command: |
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"
            
            echo "üîç Downloading test coverage map from Gist for << parameters.target_env >>..."
            
            # Get the appropriate Gist URL based on environment
            if [ "<< parameters.target_env >>" = "INTQA" ]; then
              GIST_URL="${TEST_COVERAGE_GIST_URL_INTQA}"
            elif [ "<< parameters.target_env >>" = "STAGINGUAT" ]; then
              GIST_URL="${TEST_COVERAGE_GIST_URL_STAGING}"
            else
              echo "‚ùå Unknown environment: << parameters.target_env >>"
              exit 1
            fi
            
            if [ -z "$GIST_URL" ]; then
              echo "‚ùå Error: Gist URL not set for << parameters.target_env >>"
              exit 1
            fi
            
            # Download the gist with token authentication
            if curl -H "Authorization: token ${GIST_TOKEN}" \
              "$GIST_URL" \
              -o coverage-map.json -f 2>/dev/null; then
              
              if [ -f "coverage-map.json" ] && [ -s "coverage-map.json" ]; then
                echo "‚úÖ Coverage map downloaded successfully"
                echo "üìä File size: $(wc -c < coverage-map.json) bytes"
                echo "export GIST_DOWNLOADED=true" >> $BASH_ENV
              else
                echo "‚ùå Failed to download coverage map - file is empty or missing"
                exit 1
              fi
            else
              echo "‚ùå Error downloading from Gist - HTTP request failed"
              exit 1
            fi

      - run:
          name: Determine Required Test Classes
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"
            
            # Extract changed Apex classes from files.txt
            if [ -f "files.txt" ]; then
              echo "üîç Finding changed Apex classes..."
              changed_classes=$(cat files.txt | grep -E '^force-app/.*classes/.*\.cls$' | grep -v '.*-meta\.xml$' | sed 's/.*classes\///' | sed 's/\.cls$//' || true)
              
              if [ -n "$changed_classes" ]; then
                echo "üìù Changed Apex classes found:"
                echo "$changed_classes"
                echo "$changed_classes" > changed_classes.txt
                echo "export APEX_CLASSES_CHANGED=true" >> $BASH_ENV
              else
                echo "‚ÑπÔ∏è No Apex classes changed"
                echo "" > changed_classes.txt
                echo "export APEX_CLASSES_CHANGED=false" >> $BASH_ENV
              fi
            else
              echo "‚ö†Ô∏è files.txt not found"
              echo "" > changed_classes.txt
              echo "export APEX_CLASSES_CHANGED=false" >> $BASH_ENV
            fi
            
            test_classes=""
            
            # PRONG 1: Look up changed classes in Gist coverage map
            if [ "$GIST_DOWNLOADED" = "true" ] && [ -f "coverage-map.json" ] && [ -s "changed_classes.txt" ]; then
              echo ""
              echo "üîç PRONG 1: Looking up test classes in coverage map..."
              
              while IFS= read -r class_name; do
                if [ -z "$class_name" ]; then
                  continue
                fi
                
                # Check if this class is in the coverage map (new structure with .Tests array)
                mapped_tests=$(jq -r ".coverage.\"$class_name\".Tests[]?" coverage-map.json 2>/dev/null || true)
                
                if [ -n "$mapped_tests" ]; then
                  echo "  ‚úì Found test classes for $class_name:"
                  echo "$mapped_tests" | while read -r test; do
                    echo "    - $test"
                  done
                  test_classes="$test_classes $mapped_tests"
                else
                  echo "  ‚ö†Ô∏è No coverage mapping found for $class_name"
                fi
              done < changed_classes.txt
            fi
            
            # PRONG 2: Find classes with 'test' in the name from changed classes
            if [ -s "changed_classes.txt" ]; then
              echo ""
              echo "üîç PRONG 2: Scanning for classes with 'test' in the name..."
              name_based_tests=$(cat changed_classes.txt | grep -i "test" || true)
              
              if [ -n "$name_based_tests" ]; then
                echo "  ‚úì Found test classes by name:"
                echo "$name_based_tests" | while read -r test; do
                  echo "    - $test"
                done
                test_classes="$test_classes $name_based_tests"
              else
                echo "  ‚ÑπÔ∏è No test classes found by name"
              fi
            fi
            
            # Combine all sets, remove duplicates, and store
            final_test_classes=$(echo "$test_classes" | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//')
            
            echo ""
            echo "üìã Final test classes to run:"
            if [ -n "$final_test_classes" ]; then
              echo "$final_test_classes" | tr ' ' '\n' | while read -r test; do
                if [ -n "$test" ]; then
                  echo "  - $test"
                fi
              done
              echo "export TEST_CLASSES='$final_test_classes'" >> $BASH_ENV
            else
              echo "  ‚ö†Ô∏è No test classes found"
              echo "export TEST_CLASSES=''" >> $BASH_ENV
            fi
            
            # Cleanup
            rm -f coverage-map.json changed_classes.txt

  # ----------------------------------------------------------
  # JWT AUTH COMMAND : Authenticate to Salesforce using JWT for the specified target environment
  # ----------------------------------------------------------
  jwt-auth:
    parameters:
      target_env:
        type: string
    steps:
      - run:
          name: Decode JWT key for << parameters.target_env >>
          command: |
            echo "${JWT_KEY_<< parameters.target_env >>}" | base64 -d > server.key 2>/dev/null \
              || echo "${JWT_KEY_<< parameters.target_env >>}" > server.key
            chmod 600 server.key

      - run:
          name: Authenticate to Salesforce (<< parameters.target_env >>)
          command: |
            sf org login jwt \
              --username "${SF_USERNAME_<< parameters.target_env >>}" \
              --jwt-key-file server.key \
              --client-id "${SF_CONSUMER_KEY_<< parameters.target_env >>}" \
              --instance-url "${SF_INSTANCEURL_<< parameters.target_env >>}" \
              --alias target \
              --set-default

  # ----------------------------------------------------------
  # DEPLOY/VALIDATE FULL-SYNC MANIFEST
  # ----------------------------------------------------------
  run-full-sync:
      parameters:
        operation:
          type: enum
          enum: [deploy, validate]
          default: deploy
      steps:
        - run:
            name: Full Manifest
            command: |
              PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
              cd "$PROJECT_DIR"
              sf project generate manifest --source-dir force-app > /dev/null

        - run:
            name: Full Sync << parameters.operation >>
            command: |
              PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
              cd "$PROJECT_DIR"

              if [ "<< parameters.operation >>" = "validate" ]; then
                sf project deploy validate \
                  --manifest package.xml \
                  --target-org target \
                  --test-level RunLocalTests \
                  --wait 360
              else
                sf project deploy start \
                  --manifest package.xml \
                  --target-org target \
                  --test-level RunLocalTests \
                  --wait 360
              fi

  run-batch-job:
    parameters:
      batch_job_name:
        type: string
      operation:
        type: enum
        enum: [deploy, validate]
        default: deploy
    steps:
      - run:
          name: Run Batch Job << parameters.batch_job_name >>
          command: |
            if [ "<< parameters.operation >>" != "deploy" ]; then
              echo "Not a deploy run (operation=<< parameters.operation >>). Skipping batch."
              exit 0
            fi

            echo "üöÄ Running << parameters.batch_job_name >> in PROD..."

            cat > run_batch.apex \<<'APEX'
            Database.executeBatch(new Batch_Initiate_DataDictionary());
            APEX

            sf apex run \
              --target-org target \
              --file run_batch.apex
  # ----------------------------------------------------------
  # DEPLOY/VALIDATE WITH TAGS + CANCEL ACTIVE DEPLOYS
  # operation: deploy | validate
  # create_tags: true|false (tags only for deploy)
  # ----------------------------------------------------------
  deploy-with-tags:
    parameters:
      tag_prefix:
        type: string
      target_env:
        type: string
      operation:
        type: enum
        enum: [deploy, validate]
        default: deploy
      create_tags:
        type: boolean
        default: true
    steps:
      - run:
          name: Cancel Existing Deploys (Safe Mode)
          command: |
            echo "üîç Checking for active deployments by 'CircleCI User'"

            ACTIVE_DEPLOYS=$(sf data query --use-tooling-api --query \
            "SELECT Id, Status, CreatedDate, NumberComponentsDeployed, NumberComponentsTotal
             FROM DeployRequest
             WHERE Status IN ('Pending','PendingValidation','InProgress')
             AND CreatedBy.Name = 'Deployment Automation'
             ORDER BY CreatedDate DESC" --json)

            echo "$ACTIVE_DEPLOYS" | jq .
            DEPLOY_IDS=$(echo "$ACTIVE_DEPLOYS" | jq -r '.result.records[].Id')

            if [ -z "$DEPLOY_IDS" ] || [ "$DEPLOY_IDS" = "null" ]; then
              echo "‚úÖ No active deployments found."
            else
              echo "‚ö†Ô∏è Deployments found ‚Äî attempting cancel..."
              for deployId in $DEPLOY_IDS; do
                echo "‚õî Canceling deployment: $deployId"
                CANCEL_OUTPUT=$(sf project deploy cancel --job-id "$deployId" 2>&1) || true
                echo "$CANCEL_OUTPUT"
              done
            fi
            true

      - run:
          name: Find Most Recent Tag
          command: |
            TAG_PREFIX="<< parameters.tag_prefix >>"
            echo "Using Tag Prefix: $TAG_PREFIX"
            git fetch --tags

            currentRef=0
            tags=$(git tag -l "${TAG_PREFIX}[0-9]*" | sort -V)

            if [ -n "$tags" ]; then
              echo "üîç Tags found:"
              echo "$tags"
              for tag in $tags; do
                refNum=$(echo "$tag" | sed -E "s/${TAG_PREFIX}([0-9]+)/\1/")
                if [ "$refNum" -gt "$currentRef" ]; then
                  currentRef=$refNum
                fi
              done
              echo "Latest tag: ${TAG_PREFIX}${currentRef}"
            else
              echo "üîç No tags found ‚Äî FIRST RUN"
              currentRef=0
              echo "export FIRST_RUN=true" >> $BASH_ENV
            fi

            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV

      - run:
          name: Build Manifest
          command: |
            source $BASH_ENV
            TAG_PREFIX="<< parameters.tag_prefix >>"

            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            echo "Comparing HEAD to tag: ${TAG_PREFIX}${CURRENT_REF}"

            git diff --diff-filter=ACMR --name-only "${TAG_PREFIX}${CURRENT_REF}" HEAD \
              | grep 'force-app/' \
              | sed -E 's#.*(force-app/.*)#\1#' > files.txt || true

            if [ -s files.txt ]; then
              echo "Changes detected:"
              cat files.txt
              mapfile -t manifest_paths < files.txt
              sf project generate manifest -p "${manifest_paths[@]}"
              echo "export CHANGES_FOUND=true" >> $BASH_ENV
            else
              echo "No delta ‚Äî full deploy required"
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
            fi

      # --------------------------------------------------------
      # Find Test Classes from Gist
      # --------------------------------------------------------
      - find-test-classes:
          target_env: << parameters.target_env >>

      # --------------------------------------------------------
      # Deploy (Delta or Full)
      # --------------------------------------------------------
      - run:
          name: Deploy Metadata
          command: |
            source $BASH_ENV

            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            echo "FIRST_RUN=$FIRST_RUN"
            echo "CHANGES_FOUND=$CHANGES_FOUND"
            echo "OPERATION=$OPERATION"
            echo "APEX_CLASSES_CHANGED=$APEX_CLASSES_CHANGED"
            echo "TEST_CLASSES=$TEST_CLASSES"

            if [ "$CHANGES_FOUND" = "true" ]; then
              echo "üîÑ DELTA deploy"
              DEPLOY_TYPE="DELTA"
            else
              if [ "$FIRST_RUN" = "true" ]; then
                echo "üöÄ FIRST RUN ‚Äî FULL DEPLOY + TAG CREATION"
                DEPLOY_TYPE="FULL_FIRST_RUN"
              else
                echo "‚ö†Ô∏è No delta ‚Äî FULL DEPLOY (NO TAG CREATION)"
                DEPLOY_TYPE="FULL_NO_TAG"
              fi

              sf project generate manifest --source-dir force-app > /dev/null
            fi
            
            # Determine test level based on what changed
            source $BASH_ENV

            if [ "$CHANGES_FOUND" = "true" ]; then
              if [ "$APEX_CLASSES_CHANGED" = "true" ]; then
                # Apex classes changed - we MUST have test classes
                if [ -z "$TEST_CLASSES" ]; then
                  echo "‚ùå ERROR: Apex classes were modified but no test classes were found"
                  echo "‚ö†Ô∏è Cannot deploy Apex changes without running tests"
                  exit 1
                else
                  echo "üìã Running deployment with specified test classes..."
                  echo "Test classes: $TEST_CLASSES"
                  
                  # Build --tests flags for each test class
                  test_args=""
                  for test_class in $TEST_CLASSES; do
                    test_args="$test_args --tests $test_class"
                  done
                  
                  echo "Executing: sf project deploy start --manifest package.xml --target-org target --test-level RunSpecifiedTests$test_args --wait 360"
                  
                  sf project deploy start \
                    --manifest package.xml \
                    --target-org target \
                    --test-level RunSpecifiedTests \
                    $test_args \
                    --wait 360
                fi
              else
                # No Apex classes changed - only metadata/config changes
                echo "‚ÑπÔ∏è No Apex classes changed - deploying with NoTestRun"
                echo "Executing: sf project deploy start --manifest package.xml --target-org target --test-level NoTestRun --wait 360"
                
                sf project deploy start \
                  --manifest package.xml \
                  --target-org target \
                  --test-level NoTestRun \
                  --wait 360
              fi
            else
              if [ "$OPERATION" = "validate" ]; then
                sf project deploy validate \
                  --manifest package.xml \
                  --target-org target \
                  --test-level RunLocalTests \
                  --wait 360
              else
                sf project deploy start \
                  --manifest package.xml \
                  --target-org target \
                  --test-level RunLocalTests \
                # No Apex classes changed - only metadata/config changes
                echo "‚ÑπÔ∏è No Apex classes changed - deploying with NoTestRun"
                echo "Executing: sf project deploy start --manifest package.xml --target-org target --test-level NoTestRun --wait 360"
                
                sf project deploy start \
                  --manifest package.xml \
                  --target-org target \
                  --test-level NoTestRun \
                  --wait 360
              fi
            fi

      - run:
          name: Create & Push Tag
          command: |
            source $BASH_ENV
            OPERATION="<< parameters.operation >>"
            CREATE_TAGS="<< parameters.create_tags >>"
            TAG_PREFIX="<< parameters.tag_prefix >>"

            if [ "$OPERATION" = "validate" ]; then
              echo "Validation run ‚Äî no tag creation."
              exit 0
            fi

            if [ "$CREATE_TAGS" != "true" ]; then
              echo "Tag creation disabled (create_tags=false)."
              exit 0
            fi

            if [ "$CHANGES_FOUND" = "true" ] || [ "$FIRST_RUN" = "true" ]; then
              PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
              cd "$PROJECT_DIR"

              if [ "$FIRST_RUN" = "true" ]; then
                newTag="${TAG_PREFIX}1"
              else
                newTag="${TAG_PREFIX}$((CURRENT_REF + 1))"
              fi

              git config user.email "circleci@cargurus.com"
              git config user.name "CircleCI"
              git tag "$newTag"
              git push origin "$newTag"
              echo "‚úîÔ∏è Created tag: $newTag"
            else
              echo "No changes ‚Äî skipping tag creation."
            fi

# ============================================================
# JOBS
# ============================================================
jobs:
  # ----------------------------------------------------------
  # INTQA FULL SYNC -  Auto Deploy with tags on PR merge to BRInt 
  # ----------------------------------------------------------
  auto-deploy-intqa:
    parameters:
      tag_prefix:
        type: string
      operation:
        type: enum
        enum: [deploy, validate]
        default: deploy
      create_tags:
        type: boolean
        default: true
    resource_class: large
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: INTQA
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>
          target_env: INTQA
          operation: << parameters.operation >>
          create_tags: << parameters.create_tags >>
      - slack/notify:
          event: fail
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_fail_1
      - slack/notify:
          event: pass
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_success_1

  # ----------------------------------------------------------
  # STAGINGUAT FULL SYNC -  Auto Deploy with tags on PR merge to BRStaging
  # ----------------------------------------------------------
  auto-deploy-staging:
    parameters:
      tag_prefix:
        type: string
      operation:
        type: enum
        enum: [deploy, validate]
        default: deploy
      create_tags:
        type: boolean
        default: true
    resource_class: large
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: STAGINGUAT
      - deploy-with-tags:
          tag_prefix: << parameters.tag_prefix >>
          target_env: STAGINGUAT
          operation: << parameters.operation >>
          create_tags: << parameters.create_tags >>
      - slack/notify:
          event: fail
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_fail_1
      - slack/notify:
          event: pass
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_success_1

  # ----------------------------------------------------------
  # INTQA FULL SYNC - Validate or Deploy (Manual/API only - NO auto workflow)
  # ----------------------------------------------------------
  intqa-full-sync:
      parameters:
        operation:
          type: enum
          enum: [deploy, validate]
          default: deploy
      resource_class: large
      docker:
        - image: cimg/node:20.10
      steps:
        - checkout
        - install-tooling
        - jwt-auth:
            target_env: INTQA
        - run-full-sync:
            operation: << parameters.operation >>
        - slack/notify:
            event: fail
            channel: $SLACK_DEFAULT_CHANNEL
            template: basic_fail_1
        - slack/notify:
            event: pass
            channel: $SLACK_DEFAULT_CHANNEL
            template: basic_success_1

  # ----------------------------------------------------------
  # STAGING UAT FULL SYNC - Validate or Deploy (Manual/API only - NO auto workflow)
  # ----------------------------------------------------------
  staginguat-full-sync:
    parameters:
      operation:
        type: enum
        enum: [deploy, validate]
        default: deploy
    resource_class: large
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: STAGINGUAT
      - run-full-sync:
          operation: << parameters.operation >>
      - slack/notify:
          event: fail
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_fail_1
      - slack/notify:
          event: pass
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_success_1
  
  # ----------------------------------------------------------
  # PRODUCTION FULL SYNC - Validate or Deploy (Manual/API only - NO auto workflow)
  # ----------------------------------------------------------
  prod-full-sync:
    parameters:
      operation:
        type: enum
        enum: [deploy, validate]
        default: validate
    resource_class: large
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: PROD
      - run-full-sync:
          operation: << parameters.operation >>
      - run-batch-job:
                batch_job_name: Batch_Initiate_DataDictionary
                operation: << parameters.operation >>
      - slack/notify:
          event: fail
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_fail_1
      - slack/notify:
          event: pass
          channel: $SLACK_DEFAULT_CHANNEL
          template: basic_success_1


# ============================================================
# WORKFLOWS
# ============================================================
workflows:
  version: 2

  # ----------------------------------------------------------
  # Scheduled: Nightly Full Sync to BRInt / BRStaging
  # ----------------------------------------------------------
  scheduled-IntQa-deploy:
    when:
      and:
        - equal: [ scheduled_pipeline, << pipeline.trigger_source >> ]
        - equal: [ BRInt, << pipeline.git.branch >> ]
        - equal: [ deploy, << pipeline.parameters.action_type >> ]
    jobs:
        - intqa-full-sync:
            name: deploy-BRInt-full-sync
            context: sf-intqa
            operation: deploy

  scheduled-StagingUat-deploy:
    when:
      and:
        - equal: [ scheduled_pipeline, << pipeline.trigger_source >> ]
        - equal: [ BRStaging, << pipeline.git.branch >> ]
        - equal: [ deploy, << pipeline.parameters.action_type >> ]
    jobs:
        - staginguat-full-sync:
            name: deploy-BRStaging-full-sync
            context: sf-staging
            operation: deploy 


  # ----------------------------------------------------------
  # Scheduled: Nightly Full Sync to BRInt / BRStaging -> Validate
  # ----------------------------------------------------------

  scheduled-IntQa-validate:
    when:
      and:
        - equal: [ scheduled_pipeline, << pipeline.trigger_source >> ]
        - equal: [ BRInt, << pipeline.git.branch >> ]
        - equal: [ validate, << pipeline.parameters.action_type >> ]
    jobs:
        - intqa-full-sync:
            name: validate-BRInt
            context: sf-intqa
            operation: validate

  scheduled-StagingUat-validate:
    when:
      and:
        - equal: [ scheduled_pipeline, << pipeline.trigger_source >> ]
        - equal: [ BRStaging, << pipeline.git.branch >> ]
        - equal: [ validate, << pipeline.parameters.action_type >> ]

    jobs:
        - staginguat-full-sync:
            name: validate-BRStaging
            context: sf-staging
            operation: validate
  # ----------------------------------------------------------
  # AUTO: PR merge to BRInt / BRStaging -> deploy + tags
  # (NO main auto workflow on merge)
  # ----------------------------------------------------------
  Auto-IntQa-Deploy:
    when:
      and:
        - equal: [ webhook, << pipeline.trigger_source >> ]
        - equal: [ BRInt , << pipeline.git.branch >> ]
    jobs:
        - auto-deploy-intqa:
            name: auto-deploy-BRInt
            context: sf-intqa
            tag_prefix: "INTQA-"
            operation: deploy
            create_tags: true

  Auto-StagingUat-Deploy:
    when:
      and:
        - equal: [ webhook, << pipeline.trigger_source >> ]
        - equal: [ BRStaging, << pipeline.git.branch >> ]
    jobs:
        - auto-deploy-staging:
            name: auto-deploy-BRStaging
            context: sf-staging
            tag_prefix: "STAGINGUAT-"
            operation: deploy
            create_tags: true

  # ----------------------------------------------------------
  # MANUAL: BRInt deploy or validate via action_type
  # ----------------------------------------------------------
  Manual-IntQa-Deploy:
    when:
      and:
        - equal: [ api, << pipeline.trigger_source >> ]
        - equal: [ BRInt, << pipeline.git.branch >> ]
        - equal: [ deploy, << pipeline.parameters.action_type >> ]
    jobs:
        - intqa-full-sync:
            name: deploy-BRInt-full-sync
            context: sf-intqa
            operation: deploy
    
  Manual-IntQa-Validate:
    when:
      and:
        - equal: [ api, << pipeline.trigger_source >> ]
        - equal: [ BRInt, << pipeline.git.branch >> ]
        - equal: [ validate, << pipeline.parameters.action_type >> ]
    jobs:
        - intqa-full-sync:
            name: validate-BRInt
            context: sf-intqa
            operation: validate

  # ----------------------------------------------------------
  # MANUAL: BRStaging (API only) - deploy or validate via action_type
  # ----------------------------------------------------------
  Manual-StagingUat-Deploy:
    when:
      and:
        - equal: [ api, << pipeline.trigger_source >> ]
        - equal: [ BRStaging, << pipeline.git.branch >> ]
        - equal: [ deploy, << pipeline.parameters.action_type >> ]
    jobs:
        - staginguat-full-sync:
            name: deploy-BRStaging-full-sync
            context: sf-staging
            operation: deploy

  Manual-StagingUat-Validate:
    when:
      and:
        - equal: [ api, << pipeline.trigger_source >> ]
        - equal: [ BRStaging, << pipeline.git.branch >> ]
        - equal: [ validate, << pipeline.parameters.action_type >> ]
    jobs:
        - staginguat-full-sync:
            name: validate-BRStaging
            context: sf-staging
            operation: validate
  # ----------------------------------------------------------
  # MANUAL: main/prod (API only)
  # - Nothing triggers on merge to main because we have NO webhook workflow for main
  # - Run deploy or validate manually by passing action_type
  # ----------------------------------------------------------
  Manual-Prod-Deploy:
    when:
      and:
        - equal: [ api, << pipeline.trigger_source >> ]
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ deploy, << pipeline.parameters.action_type >> ]
    jobs:
        - prod-full-sync:
            name: deploy-main-full-sync
            context: sf-prod
            operation: deploy

  Manual-Prod-Validate:
    when:
      and:
        - equal: [ api, << pipeline.trigger_source >> ]
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ validate, << pipeline.parameters.action_type >> ]
    jobs:
        - prod-full-sync:
            name: validate-main
            context: sf-prod
            operation: validate
