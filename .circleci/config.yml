version: 2.1

orbs:
  node: circleci/node@5.0.2

# ============================================================
# COMMANDS
# ============================================================
commands:

  # ----------------------------------------------------------
  # Install Salesforce CLI + Java
  # ----------------------------------------------------------
  install-tooling:
    steps:
      - restore_cache:
          keys:
            - sf-cli-cache-v1

      - run:
          name: Install Salesforce CLI and Java
          command: |
            if ! sf --version > /dev/null 2>&1; then
              sudo npm install -g @salesforce/cli
            fi

            sudo apt-get update && sudo apt-get install -y openjdk-17-jdk
            
            echo 'export PATH=$(npm bin -g):$PATH' >> "$BASH_ENV"
            source "$BASH_ENV"

            sf --version

      - save_cache:
          key: sf-cli-cache-v1
          paths:
            - ~/.npm
            - /usr/local/lib/node_modules
            - /usr/local/bin

  # ----------------------------------------------------------
  # JWT Authentication
  # ----------------------------------------------------------
  jwt-auth:
    parameters:
      target_env:
        type: string
    steps:
      - run:
          name: Decode JWT key for << parameters.target_env >>
          command: |
            echo "${JWT_KEY_<< parameters.target_env >>}" | base64 -d > server.key 2>/dev/null || echo "${JWT_KEY_<< parameters.target_env >>}" > server.key
            chmod 600 server.key

      - run:
          name: Authenticate to Salesforce (<< parameters.target_env >>)
          command: |
            sf org login jwt \
              --username "${SF_USERNAME_<< parameters.target_env >>}" \
              --jwt-key-file server.key \
              --client-id "${SF_CONSUMER_KEY_<< parameters.target_env >>}" \
              --instance-url "${SF_INSTANCEURL_<< parameters.target_env >>}" \
              --alias target \
              --set-default

  # ----------------------------------------------------------
  # Tag-Based Deployment With Delta + Manifest Generation
  # ----------------------------------------------------------
  deploy-with-tags:
    parameters:
      test_level:
        type: string
        default: RunLocalTests
      tag_prefix:
        type: string
    steps:

      # ------------------------------------------------------
      # Identify most recent tag for this branch's prefix
      # ------------------------------------------------------
      - run:
          name: Find Most Recent Tag
          command: |
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            git fetch --tags

            currentRef=0
            currentTag=""

            tags=$(git tag -l '<< parameters.tag_prefix >>-[0-9]*' | sort -V)

            if [ -n "$tags" ]; then
              for tag in $tags; do
                refNum=$(echo $tag | cut -d '-' -f 2)
                if [ "$refNum" -gt "$currentRef" ]; then
                  currentRef=$refNum
                  currentTag=$tag
                fi
              done
              echo "Latest tag: $currentTag"
            else
              echo "No tags found for prefix << parameters.tag_prefix >>"
              currentRef=0
            fi

            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
            echo "export TAG_PREFIX=<< parameters.tag_prefix >>" >> $BASH_ENV

      # ------------------------------------------------------
      # Build package.xml manifest
      # ------------------------------------------------------
      - run:
          name: Build Package Manifest
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            if [ "$CURRENT_REF" -eq 0 ]; then
              echo "First deployment, scanning full project"
              find force-app -type f > files.txt || true
            else
              echo "Delta from tag: $CURRENT_TAG"
              git diff --name-only --relative $CURRENT_TAG HEAD | grep '^force-app/' > temp_files.txt || true

              > files.txt
              while IFS= read -r file; do
                if [ -f "$file" ]; then
                  echo "$file" >> files.txt
                fi
              done < temp_files.txt
            fi

            if [ -s files.txt ]; then
              mapfile -t manifest_paths < files.txt
              sf project generate manifest -p "${manifest_paths[@]}"
              echo "export CHANGES_FOUND=true" >> $BASH_ENV
            else
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
            fi

      # ------------------------------------------------------
      # Identify test classes dependent on changed metadata
      # ------------------------------------------------------
      - run:
          name: Identify Dependent Test Classes
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            echo "üîç Checking for Apex class changes..."
            grep -oP '(?<=classes/).*?(?=.cls)' files.txt > changed_classes.txt || true

            if [ ! -s changed_classes.txt ]; then
              echo "No Apex class changes detected. No dependent tests required."
              echo "export TEST_CLASSES=\"\"" >> $BASH_ENV
              exit 0
            fi

            echo "Changed Apex classes:"
            cat changed_classes.txt

            classList=$(paste -sd "," changed_classes.txt | sed "s/,/','/g")
            classList="'${classList}'"

            echo "SOQL Component List: $classList"

            echo "Running SOQL to find dependent test classes..."

            sf data query -q "
              SELECT RefMetadataComponentName
              FROM MetadataComponentDependency
              WHERE MetadataComponentType IN ('ApexClass','ApexTrigger')
              AND RefMetadataComponentType = 'ApexClass'
              AND RefMetadataComponentName LIKE '%Test%'
              AND MetadataComponentName IN (${classList})
            " --json > dependentTests.json

            TEST_CLASSES=$(jq -r '.result.records[].RefMetadataComponentName' dependentTests.json)

            if [ -z "$TEST_CLASSES" ]; then
              echo "‚ö†Ô∏è No dependent test classes found."
              echo "export TEST_CLASSES=\"\"" >> $BASH_ENV
            else
              echo "üéØ Dependent Test Classes:"
              echo "$TEST_CLASSES"
              echo "export TEST_CLASSES=\"$TEST_CLASSES\"" >> $BASH_ENV
            fi

      # ------------------------------------------------------
      # Deploy metadata (with dynamic test selection)
      # ------------------------------------------------------
      - run:
          name: Deploy Metadata (Dynamic Test Selection)
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            if [ "$CHANGES_FOUND" = "false" ]; then
              echo "‚úÖ No changes found to deploy."
              echo "export DEPLOYMENT_SUCCESS=false" >> $BASH_ENV
              exit 0
            fi

            if [ -n "$TEST_CLASSES" ]; then
              echo "üöÄ Deploying with RunSpecifiedTests:"
              echo "$TEST_CLASSES"

              sf project deploy start \
                --manifest package.xml \
                --target-org target \
                --test-level RunSpecifiedTests \
                --tests "$TEST_CLASSES" \
                --wait 360 \
                --ignore-conflicts
            else
              echo "üöÄ Deploying with RunLocalTests (no dependent tests detected)"

              sf project deploy start \
                --manifest package.xml \
                --target-org target \
                --test-level RunLocalTests \
                --wait 360 \
                --ignore-conflicts
            fi

            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV


      # ------------------------------------------------------
      # Create new tag after deployment
      # ------------------------------------------------------
      - run:
          name: Create & Push New Tag
          command: |
            source $BASH_ENV
            PROJECT_DIR=$(find . -name "sfdx-project.json" -exec dirname {} \; | head -n 1)
            cd "$PROJECT_DIR"

            if [ "$CHANGES_FOUND" = "true" ] && [ "$DEPLOYMENT_SUCCESS" = "true" ]; then
              NEW_REF=$((CURRENT_REF + 1))
              NEW_TAG="$TAG_PREFIX-$NEW_REF"

              git config user.email "circleci@example.com"
              git config user.name "CircleCI"

              git tag "$NEW_TAG"
              git push origin "$NEW_TAG"

            else
              echo "Skipping tagging."
            fi

# -----------------------------------------------------------------
# JOBS
# -----------------------------------------------------------------
jobs:

  # ----------------------
  # INTQA Deployment
  # ----------------------
  deploy-intqa:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: INTQA
      - deploy-with-tags:
          test_level: RunLocalTests
          tag_prefix: << parameters.tag_prefix >>
      - run:
          name: Move Test Results
          command: |
            mkdir -p test-results
            find . -type d -name "test-results" ! -path "./test-results" -exec cp -r {}/* test-results/ \; || true
      - store_test_results:
          path: test-results
      - store_artifacts:
          path: test-results
          destination: apex-test-results

  # ----------------------
  # STAGING Deployment
  # ----------------------
  deploy-staging:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: STAGINGUAT
      - deploy-with-tags:
          test_level: RunLocalTests
          tag_prefix: << parameters.tag_prefix >>
      - run:
          name: Move Test Results
          command: |
            mkdir -p test-results
            find . -type d -name "test-results" ! -path "./test-results" -exec cp -r {}/* test-results/ \; || true
      - store_test_results:
          path: test-results
      - store_artifacts:
          path: test-results
          destination: apex-test-results

  # ----------------------
  # PROD Deployment
  # ----------------------
  deploy-main:
    parameters:
      tag_prefix:
        type: string
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth:
          target_env: PROD
      - deploy-with-tags:
          test_level: RunLocalTests
          tag_prefix: << parameters.tag_prefix >>
      - run:
          name: Move Test Results
          command: |
            mkdir -p test-results
            find . -type d -name "test-results" ! -path "./test-results" -exec cp -r {}/* test-results/ \; || true
      - store_test_results:
          path: test-results
      - store_artifacts:
          path: test-results
          destination: apex-test-results

# -----------------------------------------------------------------
# WORKFLOWS
# --------------------------- --------------------------------------
workflows:
  version: 2
  
  build-test-deploy:
    jobs:
      - deploy-intqa:
          context: sf-intqa
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: BRInt

      - deploy-staging:
          context: sf-staging
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: BRStaging

      - deploy-main:
          context: sf-prod
          tag_prefix: << pipeline.git.branch >>
          filters:
            branches:
              only: main
