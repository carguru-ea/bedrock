version: 2.1

orbs:
  node: circleci/node@5.0.2

# ============================================================
# COMMANDS
# ============================================================
commands:

  # ----------------------------------------------------------
  # Install Salesforce CLI + Java
  # ----------------------------------------------------------
  install-tooling:
    steps:
      - restore_cache:
          keys:
            - sf-cli-cache-v1
      - run:
          name: Install Salesforce CLI and Java
          command: |
            echo "üîß [install-tooling] Starting tooling installation..."
            if ! sf --version > /dev/null 2>&1; then
              echo "üì¶ [install-tooling] Salesforce CLI not found. Installing..."
              sudo npm install -g @salesforce/cli
            else
              echo "‚úÖ [install-tooling] Salesforce CLI already installed."
            fi

            echo "‚òï [install-tooling] Installing Java (openjdk-17-jdk)..."
            sudo apt-get update && sudo apt-get install -y openjdk-17-jdk

            echo "üß≠ [install-tooling] Updating PATH with npm global bin..."
            echo 'export PATH=$(npm bin -g):$PATH' >> "$BASH_ENV"
            source "$BASH_ENV"

            echo "üîç [install-tooling] sf --version:"
            sf --version

            echo "‚úÖ [install-tooling] Tooling setup completed."
      - save_cache:
          key: sf-cli-cache-v1
          paths:
            - ~/.npm
            - /usr/local/lib/node_modules
            - /usr/local/bin


  # ----------------------------------------------------------
  # JWT Authentication (INTQA)
  # ----------------------------------------------------------
  jwt-auth-intqa:
    steps:
      - run:
          name: Decode JWT Key (INTQA)
          command: |
            echo "üîê [jwt-auth-intqa] Decoding JWT key for INTQA..."
            echo "$JWT_KEY_INTQA" | base64 -d > server.key 2>/dev/null || echo "$JWT_KEY_INTQA" > server.key
            chmod 600 server.key
            echo "‚úÖ [jwt-auth-intqa] JWT key prepared."
      - run:
          name: Authenticate to INTQA
          command: |
            echo "üîë [jwt-auth-intqa] Authenticating to INTQA org..."
            sf org login jwt \
              --username "$SF_USERNAME_INTQA" \
              --jwt-key-file server.key \
              --client-id "$SF_CONSUMER_KEY_INTQA" \
              --instance-url "$SF_INSTANCEURL_INTQA" \
              --alias target \
              --set-default

            echo "‚úÖ [jwt-auth-intqa] Authenticated to INTQA as default alias 'target'."


  # ----------------------------------------------------------
  # JWT Authentication (STAGING)
  # ----------------------------------------------------------
  jwt-auth-staging:
    steps:
      - run:
          name: Decode JWT Key (STAGING)
          command: |
            echo "üîê [jwt-auth-staging] Decoding JWT key for STAGING..."
            echo "$JWT_KEY_STAGINGUAT" | base64 -d > server.key 2>/dev/null || echo "$JWT_KEY_STAGINGUAT" > server.key
            chmod 600 server.key
            echo "‚úÖ [jwt-auth-staging] JWT key prepared."
      - run:
          name: Authenticate to STAGINGUAT
          command: |
            echo "üîë [jwt-auth-staging] Authenticating to STAGINGUAT org..."
            sf org login jwt \
              --username "$SF_USERNAME_STAGINGUAT" \
              --jwt-key-file server.key \
              --client-id "$SF_CONSUMER_KEY_STAGINGUAT" \
              --instance-url "$SF_INSTANCEURL_STAGINGUAT" \
              --alias target \
              --set-default

            echo "‚úÖ [jwt-auth-staging] Authenticated to STAGINGUAT as default alias 'target'."


  # ----------------------------------------------------------
  # JWT Authentication (PROD)
  # ----------------------------------------------------------
  jwt-auth-prod:
    steps:
      - run:
          name: Decode JWT Key (PROD)
          command: |
            echo "üîê [jwt-auth-prod] Decoding JWT key for PROD..."
            echo "$JWT_KEY_PROD" | base64 -d > server.key 2>/dev/null || echo "$JWT_KEY_PROD" > server.key
            chmod 600 server.key
            echo "‚úÖ [jwt-auth-prod] JWT key prepared."
      - run:
          name: Authenticate to PROD
          command: |
            echo "üîë [jwt-auth-prod] Authenticating to PROD org..."
            sf org login jwt \
              --username "$SF_USERNAME_PROD" \
              --jwt-key-file server.key \
              --client-id "$SF_CONSUMER_KEY_PROD" \
              --instance-url "$SF_INSTANCEURL_PROD" \
              --alias target \
              --set-default

            echo "‚úÖ [jwt-auth-prod] Authenticated to PROD as default alias 'target'."


  # ----------------------------------------------------------
  # Delta Deployment Logic for INTQA (BRInt tags)
  # ----------------------------------------------------------
  deploy-intqa-with-tags:
    steps:
      - run:
          name: Context Info (INTQA)
          command: |
            echo "üìå [deploy-intqa] Starting INTQA deploy with tags..."
            echo "üìå [deploy-intqa] CIRCLE_BRANCH: $CIRCLE_BRANCH"
            echo "üìå [deploy-intqa] Using prefix: BRInt"
            echo "üìÇ [deploy-intqa] Current directory:"
            pwd
            echo "üìÅ [deploy-intqa] Repo contents:"
            ls -R
      - run:
          name: Fetch latest tags (INTQA)
          command: |
            echo "üì• [deploy-intqa] Fetching tags from remote..."
            git fetch --tags
            echo "üè∑ [deploy-intqa] All tags:"
            git tag -l
      - run:
          name: Determine latest BRInt tag
          command: |
            PREFIX="BRInt"
            currentRef=0
            currentTag=""

            echo "üîé [deploy-intqa] Looking for tags with prefix: $PREFIX-*"
            tags=$(git tag -l "${PREFIX}-*")
            echo "üè∑ [deploy-intqa] Matching tags: $tags"

            if [ -n "$tags" ]; then
              for tag in $tags; do
                num=$(echo "$tag" | awk -F'-' '{print $NF}')
                echo "‚û°Ô∏è [deploy-intqa] Checking tag: $tag (num=$num)"
                if [ "$num" -gt "$currentRef" ]; then
                  currentRef="$num"
                  currentTag="$tag"
                fi
              done
            else
              echo "‚ö†Ô∏è [deploy-intqa] No tags found for prefix $PREFIX. This will be the first deploy with tagging."
            fi

            echo "‚úîÔ∏è [deploy-intqa] Latest tag: $currentTag"
            echo "‚úîÔ∏è [deploy-intqa] Current reference number: $currentRef"

            echo "export PREFIX=$PREFIX" >> $BASH_ENV
            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
      - run:
          name: Build delta package (INTQA)
          command: |
            source $BASH_ENV
            echo "üì¶ [deploy-intqa] Building delta package..."
            echo "üì¶ [deploy-intqa] CURRENT_TAG: $CURRENT_TAG"
            echo "üì¶ [deploy-intqa] CURRENT_REF: $CURRENT_REF"

            if [ "$CURRENT_REF" -eq 0 ]; then
              echo "‚ö†Ô∏è [deploy-intqa] No previous tags. Deploying FULL package from force-app..."
              find force-app -type f > files.txt
            else
              echo "üîÅ [deploy-intqa] Generating delta from $CURRENT_TAG ‚Üí HEAD..."
              git diff --name-only "$CURRENT_TAG" HEAD | grep "^force-app/" > files.txt || true
            fi

            if [ ! -s files.txt ]; then
              echo "‚ùå [deploy-intqa] No changes found under force-app. Skipping deployment."
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
              exit 0
            fi

            echo "üìÑ [deploy-intqa] Changed files:"
            cat files.txt

            mapfile -t manifest_paths < files.txt
            echo "üßæ [deploy-intqa] Generating manifest from changed files..."
            sf project generate manifest -p "${manifest_paths[@]}"

            echo "export CHANGES_FOUND=true" >> $BASH_ENV
            echo "‚úÖ [deploy-intqa] Manifest generated and CHANGES_FOUND=true."
      - run:
          name: Deploy to INTQA
          command: |
            source $BASH_ENV
            echo "üöÄ [deploy-intqa] Starting deployment to INTQA..."
            echo "üöÄ [deploy-intqa] CHANGES_FOUND = ${CHANGES_FOUND:-unset}"

            if [ "${CHANGES_FOUND:-false}" != "true" ]; then 
              echo "‚è≠Ô∏è [deploy-intqa] Skipping deploy because CHANGES_FOUND != true."
              exit 0
            fi

            echo "üì§ [deploy-intqa] Running sf project deploy start..."
            DEPLOY_OUT=$(sf project deploy start --manifest package.xml --target-org target --wait 0 --verbose)
            echo "üì§ [deploy-intqa] Raw deploy output:"
            echo "$DEPLOY_OUT"

            JOB_ID=$(echo "$DEPLOY_OUT" | grep -o "0Af[a-zA-Z0-9]\+")
            echo "üÜî [deploy-intqa] Deployment Job ID: $JOB_ID"

            if [ -z "$JOB_ID" ]; then
              echo "‚ùå [deploy-intqa] Could not parse JOB_ID from deploy output. Failing."
              exit 1
            fi

            echo "üîÑ [deploy-intqa] Polling deployment status..."
            while true; do
              STATUS=$(sf project deploy report --job-id "$JOB_ID" --json | jq -r ".result.status")
              echo "üìå [deploy-intqa] Status: $STATUS"
              if [[ "$STATUS" == "Succeeded" || "$STATUS" == "Failed" ]]; then break; fi
              sleep 15
            done

            if [ "$STATUS" == "Failed" ]; then
              echo "‚ùå [deploy-intqa] Deployment failed."
              exit 1
            fi

            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV
            echo "üéâ [deploy-intqa] Deployment succeeded!"
      - run:
          name: Create new BRInt tag
          command: |
            source $BASH_ENV

            echo "üè∑ [deploy-intqa] Preparing to create new tag..."
            echo "üè∑ [deploy-intqa] PREFIX = ${PREFIX:-unset}"
            echo "üè∑ [deploy-intqa] CURRENT_REF = ${CURRENT_REF:-unset}"
            echo "üè∑ [deploy-intqa] DEPLOYMENT_SUCCESS = ${DEPLOYMENT_SUCCESS:-unset}"

            if [ "${DEPLOYMENT_SUCCESS:-false}" = "true" ]; then
              NEW_REF=$((CURRENT_REF + 1))
              NEW_TAG="${PREFIX}-${NEW_REF}"

              echo "üè∑ [deploy-intqa] Creating tag: $NEW_TAG"
              git tag "$NEW_TAG"
              git push origin "$NEW_TAG"

              echo "üéâ [deploy-intqa] Tag pushed successfully: $NEW_TAG"
            else
              echo "‚ö†Ô∏è [deploy-intqa] Deployment not successful ‚Äî skipping tag creation."
            fi


  # ----------------------------------------------------------
  # Delta Deployment Logic for STAGING (BRStaging tags)
  # ----------------------------------------------------------
  deploy-staging-with-tags:
    steps:
      - run:
          name: Context Info (STAGING)
          command: |
            echo "üìå [deploy-staging] Starting STAGING deploy with tags..."
            echo "üìå [deploy-staging] CIRCLE_BRANCH: $CIRCLE_BRANCH"
            echo "üìå [deploy-staging] Using prefix: BRStaging"
            echo "üìÇ [deploy-staging] Current directory:"
            pwd
            echo "üìÅ [deploy-staging] Repo contents:"
            ls -R
      - run:
          name: Fetch latest tags (STAGING)
          command: |
            echo "üì• [deploy-staging] Fetching tags from remote..."
            git fetch --tags
            echo "üè∑ [deploy-staging] All tags:"
            git tag -l
      - run:
          name: Determine latest BRStaging tag
          command: |
            PREFIX="BRStaging"
            currentRef=0
            currentTag=""

            echo "üîé [deploy-staging] Looking for tags with prefix: $PREFIX-*"
            tags=$(git tag -l "${PREFIX}-*")
            echo "üè∑ [deploy-staging] Matching tags: $tags"

            if [ -n "$tags" ]; then
              for tag in $tags; do
                num=$(echo "$tag" | awk -F'-' '{print $NF}')
                echo "‚û°Ô∏è [deploy-staging] Checking tag: $tag (num=$num)"
                if [ "$num" -gt "$currentRef" ]; then
                  currentRef="$num"
                  currentTag="$tag"
                fi
              done
            else
              echo "‚ö†Ô∏è [deploy-staging] No tags found for prefix $PREFIX. This will be the first deploy with tagging."
            fi

            echo "‚úîÔ∏è [deploy-staging] Latest tag: $currentTag"
            echo "‚úîÔ∏è [deploy-staging] Current reference number: $currentRef"

            echo "export PREFIX=$PREFIX" >> $BASH_ENV
            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
      - run:
          name: Build delta package (STAGING)
          command: |
            source $BASH_ENV
            echo "üì¶ [deploy-staging] Building delta package..."
            echo "üì¶ [deploy-staging] CURRENT_TAG: $CURRENT_TAG"
            echo "üì¶ [deploy-staging] CURRENT_REF: $CURRENT_REF"

            if [ "$CURRENT_REF" -eq 0 ]; then
              echo "‚ö†Ô∏è [deploy-staging] No previous tags. Deploying FULL package from force-app..."
              find force-app -type f > files.txt
            else
              echo "üîÅ [deploy-staging] Generating delta from $CURRENT_TAG ‚Üí HEAD..."
              git diff --name-only "$CURRENT_TAG" HEAD | grep "^force-app/" > files.txt || true
            fi

            if [ ! -s files.txt ]; then
              echo "‚ùå [deploy-staging] No changes found under force-app. Skipping deployment."
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
              exit 0
            fi

            echo "üìÑ [deploy-staging] Changed files:"
            cat files.txt

            mapfile -t manifest_paths < files.txt
            echo "üßæ [deploy-staging] Generating manifest from changed files..."
            sf project generate manifest -p "${manifest_paths[@]}"

            echo "export CHANGES_FOUND=true" >> $BASH_ENV
            echo "‚úÖ [deploy-staging] Manifest generated and CHANGES_FOUND=true."
      - run:
          name: Deploy to STAGING
          command: |
            source $BASH_ENV
            echo "üöÄ [deploy-staging] Starting deployment to STAGING..."
            echo "üöÄ [deploy-staging] CHANGES_FOUND = ${CHANGES_FOUND:-unset}"

            if [ "${CHANGES_FOUND:-false}" != "true" ]; then 
              echo "‚è≠Ô∏è [deploy-staging] Skipping deploy because CHANGES_FOUND != true."
              exit 0
            fi

            echo "üì§ [deploy-staging] Running sf project deploy start..."
            DEPLOY_OUT=$(sf project deploy start --manifest package.xml --target-org target --wait 0 --verbose)
            echo "üì§ [deploy-staging] Raw deploy output:"
            echo "$DEPLOY_OUT"

            JOB_ID=$(echo "$DEPLOY_OUT" | grep -o "0Af[a-zA-Z0-9]\+")
            echo "üÜî [deploy-staging] Deployment Job ID: $JOB_ID"

            if [ -z "$JOB_ID" ]; then
              echo "‚ùå [deploy-staging] Could not parse JOB_ID from deploy output. Failing."
              exit 1
            fi

            echo "üîÑ [deploy-staging] Polling deployment status..."
            while true; do
              STATUS=$(sf project deploy report --job-id "$JOB_ID" --json | jq -r ".result.status")
              echo "üìå [deploy-staging] Status: $STATUS"
              if [[ "$STATUS" == "Succeeded" || "$STATUS" == "Failed" ]]; then break; fi
              sleep 15
            done

            if [ "$STATUS" == "Failed" ]; then
              echo "‚ùå [deploy-staging] Deployment failed."
              exit 1
            fi

            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV
            echo "üéâ [deploy-staging] Deployment succeeded!"
      - run:
          name: Create new BRStaging tag
          command: |
            source $BASH_ENV

            echo "üè∑ [deploy-staging] Preparing to create new tag..."
            echo "üè∑ [deploy-staging] PREFIX = ${PREFIX:-unset}"
            echo "üè∑ [deploy-staging] CURRENT_REF = ${CURRENT_REF:-unset}"
            echo "üè∑ [deploy-staging] DEPLOYMENT_SUCCESS = ${DEPLOYMENT_SUCCESS:-unset}"

            if [ "${DEPLOYMENT_SUCCESS:-false}" = "true" ]; then
              NEW_REF=$((CURRENT_REF + 1))
              NEW_TAG="${PREFIX}-${NEW_REF}"

              echo "üè∑ [deploy-staging] Creating tag: $NEW_TAG"
              git tag "$NEW_TAG"
              git push origin "$NEW_TAG"

              echo "üéâ [deploy-staging] Tag pushed successfully: $NEW_TAG"
            else
              echo "‚ö†Ô∏è [deploy-staging] Deployment not successful ‚Äî skipping tag creation."
            fi


  # ----------------------------------------------------------
  # Delta Deployment Logic for PROD (main tags)
  # ----------------------------------------------------------
  deploy-prod-with-tags:
    steps:
      - run:
          name: Context Info (PROD)
          command: |
            echo "üìå [deploy-prod] Starting PROD deploy with tags..."
            echo "üìå [deploy-prod] CIRCLE_BRANCH: $CIRCLE_BRANCH"
            echo "üìå [deploy-prod] Using prefix: main"
            echo "üìÇ [deploy-prod] Current directory:"
            pwd
            echo "üìÅ [deploy-prod] Repo contents:"
            ls -R
      - run:
          name: Fetch latest tags (PROD)
          command: |
            echo "üì• [deploy-prod] Fetching tags from remote..."
            git fetch --tags
            echo "üè∑ [deploy-prod] All tags:"
            git tag -l
      - run:
          name: Determine latest main tag
          command: |
            PREFIX="main"
            currentRef=0
            currentTag=""

            echo "üîé [deploy-prod] Looking for tags with prefix: $PREFIX-*"
            tags=$(git tag -l "${PREFIX}-*")
            echo "üè∑ [deploy-prod] Matching tags: $tags"

            if [ -n "$tags" ]; then
              for tag in $tags; do
                num=$(echo "$tag" | awk -F'-' '{print $NF}')
                echo "‚û°Ô∏è [deploy-prod] Checking tag: $tag (num=$num)"
                if [ "$num" -gt "$currentRef" ]; then
                  currentRef="$num"
                  currentTag="$tag"
                fi
              done
            else
              echo "‚ö†Ô∏è [deploy-prod] No tags found for prefix $PREFIX. This will be the first deploy with tagging."
            fi

            echo "‚úîÔ∏è [deploy-prod] Latest tag: $currentTag"
            echo "‚úîÔ∏è [deploy-prod] Current reference number: $currentRef"

            echo "export PREFIX=$PREFIX" >> $BASH_ENV
            echo "export CURRENT_REF=$currentRef" >> $BASH_ENV
            echo "export CURRENT_TAG=$currentTag" >> $BASH_ENV
      - run:
          name: Build delta package (PROD)
          command: |
            source $BASH_ENV
            echo "üì¶ [deploy-prod] Building delta package..."
            echo "üì¶ [deploy-prod] CURRENT_TAG: $CURRENT_TAG"
            echo "üì¶ [deploy-prod] CURRENT_REF: $CURRENT_REF"

            if [ "$CURRENT_REF" -eq 0 ]; then
              echo "‚ö†Ô∏è [deploy-prod] No previous tags. Deploying FULL package from force-app..."
              find force-app -type f > files.txt
            else
              echo "üîÅ [deploy-prod] Generating delta from $CURRENT_TAG ‚Üí HEAD..."
              git diff --name-only "$CURRENT_TAG" HEAD | grep "^force-app/" > files.txt || true
            fi

            if [ ! -s files.txt ]; then
              echo "‚ùå [deploy-prod] No changes found under force-app. Skipping deployment."
              echo "export CHANGES_FOUND=false" >> $BASH_ENV
              exit 0
            fi

            echo "üìÑ [deploy-prod] Changed files:"
            cat files.txt

            mapfile -t manifest_paths < files.txt
            echo "üßæ [deploy-prod] Generating manifest from changed files..."
            sf project generate manifest -p "${manifest_paths[@]}"

            echo "export CHANGES_FOUND=true" >> $BASH_ENV
            echo "‚úÖ [deploy-prod] Manifest generated and CHANGES_FOUND=true."
      - run:
          name: Deploy to PROD
          command: |
            source $BASH_ENV
            echo "üöÄ [deploy-prod] Starting deployment to PROD..."
            echo "üöÄ [deploy-prod] CHANGES_FOUND = ${CHANGES_FOUND:-unset}"

            if [ "${CHANGES_FOUND:-false}" != "true" ]; then 
              echo "‚è≠Ô∏è [deploy-prod] Skipping deploy because CHANGES_FOUND != true."
              exit 0
            fi

            echo "üì§ [deploy-prod] Running sf project deploy start..."
            DEPLOY_OUT=$(sf project deploy start --manifest package.xml --target-org target --wait 0 --verbose)
            echo "üì§ [deploy-prod] Raw deploy output:"
            echo "$DEPLOY_OUT"

            JOB_ID=$(echo "$DEPLOY_OUT" | grep -o "0Af[a-zA-Z0-9]\+")
            echo "üÜî [deploy-prod] Deployment Job ID: $JOB_ID"

            if [ -z "$JOB_ID" ]; then
              echo "‚ùå [deploy-prod] Could not parse JOB_ID from deploy output. Failing."
              exit 1
            fi

            echo "üîÑ [deploy-prod] Polling deployment status..."
            while true; do
              STATUS=$(sf project deploy report --job-id "$JOB_ID" --json | jq -r ".result.status")
              echo "üìå [deploy-prod] Status: $STATUS"
              if [[ "$STATUS" == "Succeeded" || "$STATUS" == "Failed" ]]; then break; fi
              sleep 15
            done

            if [ "$STATUS" == "Failed" ]; then
              echo "‚ùå [deploy-prod] Deployment failed."
              exit 1
            fi

            echo "export DEPLOYMENT_SUCCESS=true" >> $BASH_ENV
            echo "üéâ [deploy-prod] Deployment succeeded!"
      - run:
          name: Create new main tag
          command: |
            source $BASH_ENV

            echo "üè∑ [deploy-prod] Preparing to create new tag..."
            echo "üè∑ [deploy-prod] PREFIX = ${PREFIX:-unset}"
            echo "üè∑ [deploy-prod] CURRENT_REF = ${CURRENT_REF:-unset}"
            echo "üè∑ [deploy-prod] DEPLOYMENT_SUCCESS = ${DEPLOYMENT_SUCCESS:-unset}"

            if [ "${DEPLOYMENT_SUCCESS:-false}" = "true" ]; then
              NEW_REF=$((CURRENT_REF + 1))
              NEW_TAG="${PREFIX}-${NEW_REF}"

              echo "üè∑ [deploy-prod] Creating tag: $NEW_TAG"
              git tag "$NEW_TAG"
              git push origin "$NEW_TAG"

              echo "üéâ [deploy-prod] Tag pushed successfully: $NEW_TAG"
            else
              echo "‚ö†Ô∏è [deploy-prod] Deployment not successful ‚Äî skipping tag creation."
            fi


# =====================================================================
# JOBS  
# =====================================================================

jobs:

  # ------------------------------
  # PROD JOB
  # ------------------------------
  deploy-prod:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-prod
      - deploy-prod-with-tags   # PROD-specific deploy logic


  # ------------------------------
  # STAGING JOB
  # ------------------------------
  deploy-staging:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-staging
      - deploy-staging-with-tags   # STAGING-specific deploy logic


  # ------------------------------
  # INTQA JOB
  # ------------------------------
  deploy-intqa:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-intqa
      - deploy-intqa-with-tags


  # ------------------------------
  # INTQA TEST JOB
  # ------------------------------
  brint-test-pipeline:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-intqa
      - deploy-intqa-with-tags


  # ------------------------------
  # STAGING TEST JOB
  # ------------------------------
  brstaging-test-pipeline:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-staging
      - deploy-staging-with-tags


  # ------------------------------
  # PROD TEST JOB
  # ------------------------------
  main-test-pipeline:
    docker:
      - image: cimg/node:20.10
    steps:
      - checkout
      - install-tooling
      - jwt-auth-prod
      - deploy-prod-with-tags


# =====================================================================
# WORKFLOWS
# =====================================================================
workflows:
  version: 2

  deploy-intqa-pipeline:
    jobs:
      - deploy-intqa:
          context: sf-intqa
          filters:
            branches:
              only: BRInt

  deploy-staging-pipeline:
    jobs:
      - deploy-staging:
          context: sf-staging
          filters:
            branches:
              only: BRStaging

  deploy-prod-pipeline:
    jobs:
      - deploy-prod:
          context: sf-prod
          filters:
            branches:
              only: main

  test-brint-deploy:
    jobs:
      - brint-test-pipeline:
          context: sf-intqa
          filters:
            branches:
              only: circleCI-BRInt

  test-brstaging-deploy:
    jobs:
      - brstaging-test-pipeline:
          context: sf-staging
          filters:
            branches:
              only: circleCI-BRStaging

  test-main-deploy:
    jobs:
      - main-test-pipeline:
          context: sf-prod
          filters:
            branches:
              only: circleCI-mainTest
